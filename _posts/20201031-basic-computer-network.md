---
title: 计算机网络基础知识
original: true
date: 2020-10-31
updated: 
tags: 
  - Network
  - Note
urlname: basic-computer-network
---
记录计算机网络学习的笔记. 
<!--more-->
# 1. 计算机网络和因特网

互联网是一个连接了全世界数以亿计的计算设备的网络. 以前这些计算设备通常是传统的桌面PC, Linux工作站或者说是服务器(用于提供存储传输Web页面和电子邮件等信息). 而现在越来越多非传统的因特网设备和因特网相连(如手机, 平板, 相机, 汽车等). 所有这些设备都成为主机(host)或端系统(end system). 

![](/picture/2020-10-31-17-32-02.png)

端系统通过通信链路(communication link)和分组交换机(packet switch)连接到一起. 
- 通讯链路: 可能是同轴电缆, 铜线, 光纤等, 不同链路提供不同的速率. 
- 分组交换机: 可能是路由器(router), 链路交换机(link-layer switch)等. 

当一台端系统向另一台端系统发送数据时, 发送端会把数据分段, 为每段加上首部字节, 形成数据包分组(packet, 也叫数据包), 然后分组交换机就负责将这些分组, 向着它们需要到达的地方转发传输. 

## 1.1 网络的核心部分

在应用层中, 端系统之间彼此交换的是**报文**(message), 报文中包含协议设计者需要的任何东西. 可以理解成不同的内容, 比如可以执行的内容, 也可以是数据(电子邮件数据, JPEG图像或者是音频等). 为了能移动这些报文(也就是数据), 通过网络链路和交换机来实现有两种基本方法. 
- 分组交换(packet switching)
- 电路交换(circuit switching)

下面就只讲用得比较多的的分组交换: 

### 1.1.1 分组交换

分组交换会将长报文划分为较小的数据块, 称之为**分组**(packet). 多数分组交换机在链路的输入端采用**存储转发传输机制**(store-and-forward transmission). 简单来说就是分组交换机在转发一个分组之前, 需要从上游接收并缓存整个分组. 对于每个分组交换机, 它有多条输出链路, 也就是转发到下一跳, 对于每条输出链路分组交换机会有一个**输出缓存**(output buffer) (也叫**输出队列**output queue). 

![](/picture/2020-10-31-19-58-42.png)

缓存队列是在路由器内的, 图中为了展示它所以画在了外面. 图中蓝色小方块为一个分组(packet), 红色的为丢失的分组. 
如果到达的分组需要传输到某条链路, 但发现链路正忙于传输其他分组, 那么到达分组需要在输出缓存中等待, 如果缓存满了那么就会出现分组丢失(**丢包**, 也就是图中红色的小方块). 到达的分组或者排队中的分组之一会被丢弃. 
因此数据传输过程中除了**存储转发时延**以外, 分组还要承受输出缓存的**排队时延**(queue delay). 

那路由器是怎么知道分组要转发给哪个路由呢? 

不同计算机网络是使用不同的方式完成的, 下面就简要说一下因特网中采用的方法. 
在因特网中每个端系统具有一个**IP地址**, 报文划分为分组时, 分组的首部就包含了目的地的IP地址. 当一个分组到达网络中的路由器时, 路由器会检查该分组的目的地址, 将该地址与路由器自身维护的**转发表**(forwarding table)对照查询, 查询到适当的输出链路, 那么路由器就会将该分组导向该出链路. 
至于转发表是怎么来的, 作者说后面再说. 总之因特网具有一些特殊的**路由选择协议**(routing protocol)用于自动设置这些转发表. 

## 1.2 分组交换的时延

分组从一个结点沿路到后继节点过程中, 它在每个结点都经受了几种不同类型的时延. 其中最重要的为: 
- 结点处理时延(nodal processing delay): 检查比特级别的差错需要的时间, 检查首部以及决定将该分组导向何处需要的时间. 
- 排队时延(queuing delay): 取决于先到达的正在排队的分组数量. 
- 传输时延(transmission delay): 取决于分组的长度以及链路的传输速率. 
- 传播时延(propagation delay): 取决于链路的物理媒体(光纤, 双绞铜线等). 也与链路的长度有关. 

# 2. 体系结构

##  2.1 结构模型

首先是OSI和TCP/IP的分层模型和对应关系: 

![](/picture/2020-10-30-23-59-13.png)

OSI参考模型一共分7层, 一般用于教学, 实际使用更多的是TCP/IP的5层模型. 5层体系模型为: 
- **应用层**: 网络应用程序以及他们的应用层协议留存的地方. (如: HTTP提供Web文档请求和传送; SMTP提供电子邮件报文的传输; FTP提供两个端系统间文件传送; DNS域名解析系统等) 位于应用层的信息分组称为**报文**(message). 
- **运输层**: 因特网的运输层在应用程序端点之间传送应用层报文. 因特网中有TCP和UDP这两种协议. TCP向应用程序提供了面向连接的服务, 包括应用层报文确保传递和流量控制机制, 会将长报文划分为短报文, 并提供拥塞控制机制. UDP面向无连接, 上面TCP有的它没有. 位于运输层的分组称为**报文段**(segment). 
- **网络层**: 负责将称为**数据报**(datagram)的网络分组从一台主机移动到另一台. 上一层运输层会给网络层提供 报文段 和 目的地址 . 这一层包括著名的IP协议与许多路由选择协议, 但通常也会被称为IP层. 
- **链路层**: 链路层负责将数据报传递给下一个结点. 它提供的服务取决于应用于该链路层的特定链路协议. 比如某些协议基于链路提供可靠传递, 但是这种可靠传递不同于TCP的端系统对端系统的可靠交付, 而是包括以太网, WiFi和电缆接入网的DOCSIS协议. 因为数据报从源到目的地传送通常需要经过几条链路, 所以一个数据报可能被沿途不同链路上的不同链路层协议处理. 链路层的分组称为**帧**(frame). 
- **物理层**: 物理层的任务是将帧中的一个个**比特**从一个结点移动到下一结点. 这一层中的协议仍是链路相关的, 并且进一步与该层链路(例如: 双绞铜线, 单模光纤)的实际传输媒体相关. 比如: 以太网就有许多物理层协议, 有基于双绞铜线的, 有基于同轴电缆的, 还有基于光纤的... 在每种场合, 跨越这些链路移动一个比特是以不同的方式进行的. 

作者举的快递的例子非常容易理解: 我们在网上买东西, 首先确定自己所在的位置有相应的快递网点, 这个网点就相当于网络接入层, 然后需要告诉卖家地址, 这个地址相当网际互联层, 快递送货相当于传输层, 最后我们收到货物之后拆包使用相当于应用层. 
而在BS结构中, TCP/IP模型中的网络接入层没有相应协议, 网际互联层是IP协议, 传输层是TCP协议. 

我们来看一下这套结构模型在实际中是怎么运作的: 

![](/picture/2020-10-31-13-05-39.png)

可以看到用户A发送的数据, 经过一层一层**封装**(encapsulation)后发送到用户B的电脑, 然后再一层一层的拆开, 最终用户B得到用户A发送的消息, 这就是模型基本运作的样子. 

# 3. 应用层

## 3.1 应用层原理

网络应用程序的体系结构大致可以分为: 
- CS结构(client-server architecture): 由一个或多个客户端, 以及一个或多个服务端组成. 
- P2P结构(P2P architecture): 每终端都是客户端和服务端. 

下图展示了两个端系统应用层之间是如何通讯的: 
![](/picture/2020-11-01-16-05-14.png)

从一个端系统的进程向另外一个端系统的进程, 进程通过一个叫**套接字**(socket)的软件接口向网络发送报文和接收报文, 套接字是同一台主机内应用层与运输层之间的接口. 应用程序的开发者可以控制套接字在应用层端的一切, 但是对于该套接字的运输层端几乎没有控制权. 所以开发者对运输层的控制仅限于**选择运输层协议**或**设定几个运输参数**. 

在因特网中, 主机由其**IP地址**(IP address)标识, 而接收进程由目的地**端口号**(port number)标识. 一般主机都给流行的应用分配了特定的端口号, 比如Web服务器用端口号80来标识, 邮件服务进程(使用SMTP协议)用端口号25来标识. 

而在套接字另一侧是运输层协议负责把该报文进入接收进程的套接字. (如TCP/UDP协议等)
**注:**而无论TCP还是UDP都没有提供任何加密机制, 也就是传进套接字的数据, 跟到达目的地进程的数据是一样的. 意思就是如果中途链路有人嗅探, 那么他能看到传输的数据. 因此为了隐私和其他安全问题现在已经研制了加强版**安全套接字层**(Secure Sockets Layer, SSL). 它能提供进程到进程的安全性服务, 但它和TCP和UDP不在同一个层次上, 它是对TCP的加强, 这种强化是在应用层实现的. 

## 3.2 应用层协议(application-layer protocol)

应用层协议定义了不同端系统上的应用程序进程如何相互传递报文. 比如报文类型, 报文语法, 字段语义, 何时如何发送等. 

### 3.2.1 Web和HTTP

Web的应用层协议是**超文本传输协议**(HyperText Transfer Protocol, HTTP). Web页面(Web page)(也叫文档)是由**对象**(object)组成的, 如一个HTML文件, 一个JPEG图形, 一个Java小程序这样的文件就是对象. 多数Web页面含有一个HTML基本文件(base HTML file)以及几个引用对象. 例如一个Web页面包含HTML文本和5个JPEG图形, 那么这个Web页面就有6个对象. 而**Web浏览器**(Web browser)实现了HTTP客户端, **Web服务器**(Web server)实现了HTTP的服务器端. 服务器向用户发送被客户端请求的资源, 假设一个用户在短短几秒钟内两次请求同一个对象, 但是服务器并不会因为刚刚给用户发送了它就不发送了, 而是和第一次请求时一样重新发送资源, 就好像服务器不记得之前做过这件事情一样. 因为HTTP服务器不会保存用户的相关信息, 所以我们说HTTP是一个**无状态协议**(stateless protocol). 

我们都知道HTTP协议作为应用层的协议, 他在发送请求和接收报文时会使用传输层的TCP协议, 而TCP协议在建立连接时是需要进行"三次握手"的. 而在很多因特网应用程序中, 客户在一台服务器上停留的时间是比较久的, 如果客户的每一次请求和响应都需要经历"三次握手", 那会消耗公用的网络资源. 所以就有请求和响应在一次TCP连接中完成, 而不是每次请求和响应都要建立一次TCP连接. 这就是**持续性连接**(persistent connection)和**非持续性连接**(non-persistent connection)的区别. 

HTTP请求报文
下面是一个典型的HTTP请求报文: 
~~~
GET /somedir/page.html HTTP/l.l
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
~~~
它的第一行叫做**请求行**(request line), 其后继的行叫做**首部行**(header line). 
请求行: 
- 第一个字段是请求方法字段, 包括GET, POST, HEAD, PUT和DELETE. 
- 第二个字段是URL字段. 统一资源定位符. 
- 第三个字段是HTTP版本字段. 

首部行: 
- Host: 指明主机, 用于Web代理高速缓存. 
- Connection: close. 这一行表示不希望用持续性连接, 要求服务器发送完被请求对象后就关闭连接. 
- User-agent: 指明用户代理, 发送请求的浏览器类型. 
- Accept-language: 用户想得到该对象的什么语言的版本(如果服务器支持的话). 

下图是请求报文通用格式, 如果是GET方法时实体主体为空, 如果是POST就可以包含实体主体. 而GET可以在URL中用?带参. 
![](/picture/2020-11-01-23-13-44.png)

下面是典型的HTTP响应报文: 
~~~
HTTP/1.1 200 OK
Connection: close
Date: Tue , 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue , 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
(data data data data data ...)
~~~
它由三个部分组成: 一个初始**状态行**(status line), 6个**首部行**(header line), 然后是**实体体**(entity body). 
状态行: 
- 第一个字段是协议版本
- 第二个字段是状态码
- 第三个字段是相应状态信息

首部行: 
- Connection: close. 告诉客户, 发送完报文后将关闭该TCP连接. 
- Date: 服务器产生并发送该相应报文的日期和时间. (是检索到对象, 插入到报文, 并发送该响应报文的时间)
- Server: 类似于HTTP请求中的User-agent, 表名是什么服务器产生的. 
- Last-Modified: 对本地客户或者网络缓存服务器上的对象缓存有用. 
- Content-Length: 被发送对象中的字节数. 
- Content-Type: 对象类型. 

![](/picture/2020-11-01-23-35-08.png)

那么用户是如何与服务器交互的呢? 

这里就要用到**cookie**了, cookie技术有4个组件: 
- 在HTTP响应报文中的一个cookie首部行. 
- 在HTTP请求报文中的一个cookie首部行. 
- 在用户端系统中保留有一个cookie文件, 并由用户的浏览器进行管理
- 位于Web站点的一个后端数据库

简单来说这种技术允许服务器追踪并记录这个客户, 因为客户端和服务端都遵循HTTP协议, 只要服务端设置了cookie, 而且这个cookie没有过有效期, 那么客户端每次访问对应的服务端都会携带这个cookie, 因此服务器就会知道你访问过哪些内容, 但此时服务器并不知道你是谁, 它只认得cookie, 只要cookie存的值足够特别, 服务器就能唯一标识这个用户. 而只有在你登录了服务器后服务器将cookie与你绑定, 它才知道你是谁. 

尽管cookie能简化用户的互联网购物活动, 但是它的使用仍然有争议, 因为他们被认为是对用户隐私的一种侵害. 比如结合cookie和用户提供的账户信息, Web站点可以知道很多用户的信息, 并且可能将这些信息卖给第三方. cookie也分为第一方cookie与第三方cookie等, 这就涉及到定向广告相关的内容了. 

**Web缓存器**(Web cache)也叫**代理服务器**(proxy server), 它可以大大减少客户对请求的响应时间, 特别是客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽. 
![](/picture/2020-11-01-23-52-11.png)

通过**内容分发网络**(Content Distribution Network, CDN), Web缓存器在因特网中发挥着越来越重要的作用. 
Web缓存器给初始服务器发送的**条件GET方法**(conditional GET)的首部行包含一个" If-Modified -Since :", 如果资源对象没有被修改那么返回空对象的响应, 否则返回修改后的对象和日期. 它给判断缓存中的内容是否是陈旧的行为提高了效率. 




## 2.2. 协议

### 2.2.1 IP协议

这里说的IP协议是指Internet Protocol互联网协议, 而我们日常说得IP其实是指IP地址, 也就是一段数字. 在上面快递的例子中, IP地址相当于快递所在网点的地址, 那么在计算机网络中也是一样的, 接入互联网的设备每一台都会有一个IP地址. 在我们日常生活中, 家里办了宽带, 我们的设备能上网, 而那个宽带就包含运营商给我们提供的IP地址, 有了IP地址我们才能和互联网上其他设备进行通讯. 

### 2.2.1 DNS协议

接入到网络的计算机都会有一个IP, 有的计算机是专门给其他计算机提供服务的, 也叫服务器, 所以服务器肯定有自己的IP, 但是用户直接通过IP来访问对应服务器是不大方便的, 所以就有了域名, 而DNS协议的作用就是将域名解析成IP, 但是域名对应的IP经常在变化, 所以就需要专门将域名解析成IP的DNS服务器. 我们直接访问的DNS服务器叫本地DNS服务器, 它本身没有域名和IP对应关系, 在我们发出请求时它会从主DNS服务器获取然后保存到缓存中. 

### 2.2.2 TCP/IP协议

TCP协议和IP协议是两个不同的协议, TCP协议用来规范传输规则, 而IP协议只是负责找到地址. TCP协议在传输前会进行"三次握手", 传输完数据断开时要进行"四次挥手". 

### 2.2.3 TCP协议

TCP协议是一套规则, 如果两台计算机都遵循这个规则, 那么它们之间就可以建立一种可靠的连接, 这种可靠的连接是连接双方都遵循这个TCP协议才能建立的, 而遵守这套协议能够保证我们双方发送和接收到的消息有序且完整.  
协议的特点: 
- 面向连接, 可靠的字节流服务
- 一个TCP连接中只有两方进行通信, 广播和多播不能用于TCP
- 使用校验和, 确认和重传机制来保证可靠的传输
- 数据分节排序, 使用累积确认保证数据顺序不变和非重复
- 使用滑动窗口机制实现流量控制, 通过动态改变窗口大小进行拥塞控制 
- TCP也不是100%可靠的协议, 如果有可能就把数据送到接收方, 否则就放弃重传中断连接通知用户. 

如何建立TCP连接? 

现在计算机双方都知道我需要遵循TCP协议这个规则, 我就能跟其他也遵循这个规则的计算机通讯了, 但是我如何跟另外的TA建立连接呢? 



### 2.2.4 IP协议





参考: 
- 书籍: 计算机网络-自顶向下方法
- 书籍: 看透Spring_MVC：源代码分析与实践
- [一文彻底搞懂 TCP三次握手、四次挥手过程及原理 ](https://juejin.im/post/6844904070000410631)
- [为什么 TCP 建立连接需要三次握手](https://draveness.me/whys-the-design-tcp-three-way-handshake/)
- [TCP协议 笔试面试知识整理](https://hit-alibaba.github.io/interview/basic/network/TCP.html)