---
title: Java并发编程实战
---

# 1. 简介

## 1.2 线程的优势

线程能更好地模拟人类的工作方式和交互方式, 比如烧水时人可以做其他事. 在GUI应用程序中线程可以提高用户界面的响应灵敏度. 在服务器应用程序中线程可以提升资源利用率以及系统吞吐率. 线程还可以简化JVM的实现, 垃圾收集器通常在一个或者多个专门的线程中运行.
- 发挥多处理器的强大能力
- 建模的简单性(通常线程只完成单一的简单任务, 所以逻辑上会简单些)
- 异步事件的简化处理(作者认为服务器中使用多线程处理请求以及使用同步I/O会降低应用程序的开发难度. 而单线程服务器应用必须使用非阻塞I/O, 这种I/O的复杂性要远高于同步I/O)
- 响应更灵敏的用户界面

## 1.3 线程带来的的风险

### 安全性问题(永远不发生糟糕的事情)

执行顺序不可预测. 容易产生竞态条件(Race Condition). 因为多个线程要共享相同的内存地址空间, 并且是并发运行, 因此它们可能会访问或修改其他线程正在使用的变量. 要使多线程程序的行为可以预测, 必须对共享变量的访问操作进行协同, 而Java提供了各种同步机制来协同这种访问.

### 活跃性问题(某件正确的事情最终会发生)

当某个操作无法继续执行下去时, 就会发生活跃性问题. 在串行程序中, 活跃性问题的形式之一是无意中造成的无限循环, 使得循环之后的代码无法得到执行. 而线程将带来其他一些活跃性问题, 例如线程A等待线程B释放其持有的资源, 而线程B永远都不释放该资源, 那么A就会永久地等待下去.

### 性能问题(某件正确的事情尽快发生)

线程会带来某种程度的运行时开销. 当线程调度器临时挂起活跃线程并转而运行另一个线程时, 就会频繁的出现上下文切换(Context Switch)操作. 当线程共享数据时, 必须使用同步机制, 而这些机制往往会抑制某些编译器优化. 所有这些因素都将带来格外的性能开销.

# 2. 线程安全性(第一部分)

## 2.2 原子性

我们把"先检查后执行"(延迟初始化)和"读取-修改-写入"(递增运算)等操作称为复合操作, Java中提供了加锁机制来使上面的操作以原子方式执行. 
对于计数器的自增, 作者使用 java.util.concurrent.atomic 包中的AtomicLong来代替原来的long类型, 从而确保了对计数器状态的访问操作是原子的.

## 2.3 加锁机制

Java提供了一种内置的锁机制来支持原子性: 同步代码块(Synchronized Block). 它包括两部分:
- 一个作为锁的对象引用(如果是静态方法, 则是Class对象作为锁)
- 一个作为由这个锁保护的代码块

每个Java对象都可以作为一个实现同步的锁, 这些锁被称为**内置锁**(Intrinsic Lock)或**监视器锁**(Monitor Lock). 获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法. 线程在进入同步代码块前会自动获得锁, 在退出或者抛出异常时自动释放锁. Java的内置锁相当于一种互斥锁, 线程A尝试获取线程B持有的锁时必须等待或者阻塞, 如果B永远不释放锁, 那么A会永远等下去.

内置锁是**可重入的**, 如果某个线程试图获得一个已经由它自己持有的锁, 那么这个请求就会成功. "重入"意味着获取锁的操作粒度是"线程", 而不是"调用"(这和POSIX线程的粒度不同). 重入的一种实现方法是, 为每个锁关联一个**获取计数值**和一个**所有者线程**. 当计数值为0时, 这个锁就被认为是没有任何线程持有. 当线程请求一个未被持有的锁时, JVM将记下锁的持有者, 并将获取计数值置为1, 如果同一个线程再次获取这个锁, 计数值将递增, 而当线程退出同步代码块时, 计数器会相应地递减.
重入避免了死锁的发生.

## 2.4 用锁来保护状态

并非所有数据都需要锁的保护, 只有被多个线程同时访问的可变数据才需要通过锁来保护. 而对于每个包含多个变量的不变性条件, 其中涉及的所有变量都需要由同一个锁来保护.

如果只是每个方法都作为同步方法, 例如Vector, 那么并不足以确保Vector上复合操作都是原子的:

~~~ java
if (!vector.contains(element)) {
    vector.add(element);
}
~~~

虽然contains和add都是原子方法, 但这上面仍存在竞态条件, 还是需要格外的加锁机制.

对于同步代码块的合理大小, 需要在各种设计需求之间进行权衡, 包括安全性(这个需求必须得到满足), 简单性和性能. 当执行时间较长的计算或者可能无法快速完成的操作时(例如网络I/O或控制台I/O), 一定不要持有锁.

# 3. 对象的共享

## 3.1 可见性

## 3.3 线程封闭

## 3.4 不变性

## 3.5 安全发布

# 4. 对象的组合

## 4.1 设计线程安全的类

## 4.2 实施封闭

## 4.3 线程安全性的委托

# 5. 基础构建模块

## 5.1 同步容器类

## 5.2 并发容器

## 5.3 阻塞队列和生产者-消费者模式

## 5.4 阻塞方法与中断方法

## 5.5 同步工具类

